
### ì‚¬ìš© ë³€ìˆ˜
> $$y^2=x^3+ax+b$$ mod $$p$$

- (a, b) = curveëª¨ì–‘ì„ ê²°ì •í•˜ëŠ” ìƒìˆ˜
- p = prime num
- G = generator. base point.
- n = order of point G


### ê·¸ë˜í”„ ë‚´ G ê³„ì‚° ë°©ë²•

__ë§¨ ì²˜ìŒì—” doublingì„ ì‚¬ìš©í•´ì•¼í•œë‹¤. __
![](https://images.velog.io/images/yesterdaykite/post/f315f2c4-13c3-4015-bab5-6788ed538dde/image.png)
![](https://images.velog.io/images/yesterdaykite/post/87b0a8ef-ee9e-491c-b8ff-b63ef68f950b/image.png)

__n=151ì²˜ëŸ¼ í° ê²½ìš°ëŠ”? -> double and add algorithm __
![](https://images.velog.io/images/yesterdaykite/post/166f45a9-ecb4-4337-acd9-a0b8509075ab/image.png)



### encrypt & decrypt
__ì‚¬ìš© ë³€ìˆ˜__
- private key ($$d_A$$) : në³´ë‹¤ ì‘ì€ ëœë¤ ì •ìˆ˜
- public key ($$Q_A$$) : scalar point multiplication ì„ ì‚¬ìš©í•´ Gë¥¼ ê³„ì‚°í•œ ê²°ê³¼
	$$Q_A=d_A*G$$

__Encryption__
1. __temporary public key R ìƒì„±__
  - ëœë¤ì •ìˆ˜ r ì„ íƒ
  - R = r * G  ê³„ì‚°
  - S(secret shared point) = r * $$Q_A$$
2. __data encrypt__
  - C = S X M
  - generating H(M)
3. __Trasmission__
  - (R, C,  H(M)) ë³´ëƒ„


__Decryption__
1. __ë°›ëŠ”ê²ƒ__
  - R, C = S X M , H(M)
2. __decrypt__
  - S ê³„ì‚°í•˜ê¸°
    $$d_A*R=d_A*r*G=r*(d_A*G)=r*Q_A=S$$


__Example__
![](https://images.velog.io/images/yesterdaykite/post/80292b9f-d09d-4536-9f93-84e89024ad39/image.png)



### ECC vs RSA
- __ECCëŠ” RSA ë³´ë‹¤ ì ì€ key sizeë¡œ ê°™ì€ ìˆ˜ì¤€ì˜ ë³´ì•ˆ ë ˆë²¨ì„ achieve__
- ECCëŠ” based on discrtete logarithm -> much more difficult to challenge.
- ECC ëŠ” Quantum computerì‚¬ìš©í•˜ì—¬ discrete logarithmì„ ë¹ ë¥´ê²Œ ê³„ì‚°í•  ìˆ˜ ìˆëŠ” ê²½ìš°, Easier to break than RSA ğŸ¥²

